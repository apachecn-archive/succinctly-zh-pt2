# 五、三思而后行：单元测试的成本

前面几章已经谈到了单元测试的各种关注点和好处。本章更正式地介绍了单元测试的成本和好处。

## 单元测试代码与正在测试的代码

您的单元测试代码与正在测试的代码是一个独立的实体，但是它与您的生产代码有许多相同的问题:

*   规划
*   发展
*   测试(是的，必须测试单元测试)

此外，单元测试还可以:

*   拥有比生产代码更大的代码库。
*   当生产代码改变时需要同步。
*   倾向于加强架构方向和实现模式。

### 单元测试代码库可能大于生产代码

当确定是否可以针对单个方法编写测试时，应该考虑:

*   它验证合同了吗？
*   计算正确吗？
*   对象的内部状态设置是否正确？
*   如果发生异常，它会将对象返回到“正常”状态吗？
*   是否测试了所有代码路径？
*   该方法有什么设置或拆卸要求？

人们应该意识到，测试一个简单方法的代码行数可能比方法本身的行数大得多。

## 维护单元测试

更改生产代码通常会使单元测试无效。代码更改大致分为两类:

*   增强用户体验的新代码或对现有代码的更改。
*   重大重组，以支持现有架构不支持的需求。

前者通常对现有的单元测试很少或没有维护要求。然而，后者通常需要大量的单元测试返工，这取决于变更的复杂性:

*   将具体的类参数重构为接口或抽象类。
*   重构类层次结构。
*   用另一种技术取代第三方技术。
*   将代码重构为异步或支持任务。
*   其他:

*   示例:从具体的数据库类(如 SqlConnection)更改为 IDbConnection，这样代码就可以支持不同的数据库，并且需要对调用依赖于具体类的方法的单元测试进行返工。
*   示例:修改模型以使用标准序列化格式，如 XML，而不是自定义序列化方法。
*   示例:从内部 ORM 变更为第三方 ORM，如实体框架，可能需要对单元测试的设置或拆卸进行相当大的更改。

## 单元测试是否实现了架构范例？

如前所述，单元测试，尤其是在测试驱动的过程中，强制执行某些最小的架构和实现范例。为了进一步支持代码的某些区域的轻松设置或拆除，单元测试也可以从更复杂的架构考虑中受益，例如控制反转。

## 单元测试性能

至少，大多数类应该有助于嘲笑任何对象。这可以显著提高测试的性能——例如，测试一个执行外键完整性检查的方法(而不是依赖数据库在以后报告错误)不应该需要在数据库本身中复杂地设置或拆卸测试场景。此外，它不应该要求方法实际查询数据库。这些都是对测试的性能影响，并增加了对与数据库的实时、经过身份验证的连接的依赖，因此可能无法同时处理另一个运行完全相同测试的工作站。相反，通过模拟数据库连接，单元测试可以轻松地在内存中设置场景，并将连接对象作为接口传递。

然而，简单地嘲笑一个类也不一定是最佳实践——重构代码可能更好，这样方法需要的所有信息都可以单独获得，将数据的获取与数据的计算分开。现在，计算可以在不模仿负责获取数据的对象的情况下进行，这进一步简化了测试设置。

## 降低成本

应该考虑几个降低成本的策略。

### 正确的输入

降低单元测试成本的最有效方法是避免编写测试。虽然这听起来很明显，但这是如何实现的呢？答案是确保传递给方法的数据是正确的——换句话说——正确的输入，正确的输出(与“垃圾输入，垃圾输出”相反)。是的，您可能仍然想要测试计算本身，但是如果您能够保证调用方满足契约，那么就没有特别的必要测试该方法来查看它是否处理了不正确的参数(违反契约)。

这有点滑坡，因为你不知道该方法将来会被如何调用——事实上，你可能希望该方法仍然验证它的契约，但是*在当前使用它的上下文*中，如果你能保证契约总是被满足，那么针对契约编写测试就没有真正的意义了。

如何确保输入正确？对于来自用户界面的值，适当地过滤和控制用户交互来预过滤这些值是一种方法。更复杂的方法是定义专用类型，而不是依赖通用类型。考虑前面描述的除法方法:

```cs
    public static int Divide(int numerator, int denominator)
    {
      if (denominator == 0)
      {
        throw new ArgumentOutOfRangeException("Denominator cannot be 0.");
      }

      return numerator / denominator;
    }

```

如果分母是保证非零值的特殊类型:

```cs
    public class NonZeroDouble
    {
      protected int val;

      public int Value
      {
        get { return val; }
        set
        {
          if (value == 0)
          {
            throw new ArgumentOutOfRangeException("Value cannot be 0.");
          }

          val = value;
        }
      }
    }

```

对于这种情况，Divide 方法永远不需要测试:

```cs
    /// <summary>
    /// An example of using type specificity to avoid a contract test.
    /// </summary>
    public static int Divide(int numerator, NonZeroDouble denominator)
    {
      return numerator / denominator.Value;
    }

```

当考虑到这提高了应用程序的类型特异性并建立了(有希望的)可重用类型时，人们会意识到这如何避免必须编写大量的单元测试，因为代码经常使用过于通用的类型。

### 避免第三方异常

扪心自问——我的方法是否应该负责处理来自第三方的异常，例如 web 服务、数据库、网络连接等。？可以说，答案是“不”。当然，这需要一些进一步的前期工作——第三方(甚至框架)应用编程接口需要一个处理异常的包装器和一个架构，在该架构中，当异常发生时，应用程序的内部状态可以回滚，并且可能应该被实现。然而，无论如何，这些可能都是对应用程序值得改进的地方。

### 避免为每种方法编写相同的测试

前面的例子——正确的输入、专门化的类型系统、避免第三方异常——都将问题推到了更通用和可能可重用的代码上。这有助于避免编写相同或相似的契约验证、异常处理单元测试，并允许您将重点放在验证方法在正常情况下应该做什么的测试上，即计算本身。

## 成本效益

如前所述，单元测试有明确的成本优势。

### 根据需求编码

一个显而易见的好处是从外部可用性/过程需求中形式化内部代码需求的过程。当你完成这个练习时，对整体架构的指导通常是一个附带的好处。更具体地说，从*单元*的角度(而不是*集成测试*的角度)开发一套满足特定需求的测试是代码实现需求的客观证明。

### 减少下游误差

回归测试是另一个(通常是可测量的)好处。随着代码库的增长，验证现有代码是否仍按预期工作节省了大量的手动测试时间，并避免了“哎呀，我们没有为此进行测试”的情况。此外，当一个错误被报告时，它可以被立即纠正，这通常使团队的其他成员省去了相当头疼的问题，即为什么他们所依赖的东西突然不能正常工作。

### 测试用例提供了一种文档形式

单元测试不仅验证当给定错误输入或第三方异常时方法是否正确处理自己(如前所述，尝试减少这类测试)，还验证方法在正常情况下的预期行为。这为开发人员，尤其是新的团队成员提供了有价值的文档——通过单元测试，他们可以很容易地收集设置需求和用例。如果您的项目经历了重大的架构重构，新的单元测试可以用来指导开发人员返工他们的依赖代码。

### 实现架构范例改进架构

如前所述，通过使用接口、控制反转、专用类型等，更健壮的架构。—所有这些都有助于单元测试— *也*提高应用程序的健壮性。即使在开发过程中，需求也会发生变化，一个考虑周全的架构可以比一个没有或很少考虑架构的应用程序更好地处理这些变化。

### 初级程序员

您可以让初级程序员根据测试而不是需求来编写实现*，从而保证更高水平的代码和成功(并提供教学体验)，而不是将高级需求交给初级程序员来实现。这消除了初级程序员最终实现的大量不良实践或猜测(我们都经历过)，并减少了更高级的开发人员将来需要做的返工。*

### 代码审查

有几种代码审查。单元测试可以减少审查架构问题代码所花费的时间，因为它们倾向于加强架构。此外，单元测试验证计算，也可以用来验证给定方法的所有代码路径。这使得代码评审几乎没有必要——单元测试变成了代码的自我评审。

### 将需求转换为测试

将外部可用性或过程需求转换为正式的代码测试(及其支持架构)的一个有趣的副作用是:

*   需求的问题经常被发现。
*   建筑需求被曝光。
*   确定需求中的假设和其他差距。

作为单元测试过程的结果，这些发现在开发过程中更早地发现问题，这通常有助于减少混乱、返工，从而降低成本。