# 第 4 章数组和矩阵

我们现在可以说已经到了书中最重要的一章。请记住，MATLAB 代表 MATrix LABoratory，因此使用矩阵是 MATLAB 中所有工作的核心。在本章中，我们将了解矩阵的创建和操作方式，以及一些适用于它们的常见操作。

## 术语

在我们开始之前，请记住，MATLAB 中的所有变量实际上都是数组。我的意思是，当你写`x=5`的时候，你可能已经写了`x=[5]`，这两者都有效地暗示了一个 1×1 的数组。

在我们的讨论中，我们将交替使用术语*阵列*和*矩阵*。然而，我们将使用术语*向量*来表示一维数组。在这种情况下，我们还将使用术语*行向量*来表示占据一行的水平数组:

![](../Images/image022.png)

术语*列向量*表示占据一列的数组:

![](../Images/image023.png)

## 一维数组

初始化数组最简单的方法是声明一个变量，并使用方括号初始化它，用空格和/或逗号分隔元素:

```
    >> x = [1, 2 3 4]

    x =
         1     2     3     4

```

我们得到的是 4 个元素的行向量。如果我们想要一个列向量，我们写大致相同的东西，但我们用分号来分隔条目，而不是空格:

```
    >> y = [1;2;3;4]

    y =
         1
         2
         3
         4

```

初始化数组的一种完全不同的方法是使用冒号运算符。此运算符允许您定义包含值序列的数组。例如:

```
    >> z = 1:10

    z =
         1     2     3     4     5     6     7     8     9    10

```

上面创建了一个元素为 1 到 10 的行向量。奇怪的是，这种方法也适用于字符串，因此，例如，您可以声明一个从 **a** 到 **z** 的数组，这将产生……您猜对了，一个包含从 a 到 z 的所有字符的字符串！

```
    >> 'a':'z'

    ans =
    abcdefghijklmnopqrstuvwxyz

```

使用列运算符，不仅可以指定值范围的开始和结束，还可以指定步长。例如，这里我们生成从 1 到 15 的所有奇数:

```
    >> 1:2:15

    ans =
         1     3     5     7     9    11    13    15

```

请注意，如果您想要一组递减的值，步长需要为负，因此如果您想要以上数字按降序排列，则需要写入`15:-2:1`。

> > 15:-2:1

年=
15 13 11 9 7 5 3 1

这还不是全部。还有一个命令用于在特定范围内创建一组值。功能`linspace`将一个范围细分为几个点(默认为 100)。该函数的第三个参数允许您定义所需的点数:

```
    >> linspace(0,1,11)

    ans =
      Columns 1 through 8
             0    0.1000    0.2000    0.3000    0.4000    0.5000    0.6000    0.7000
      Columns 9 through 11
        0.8000    0.9000    1.0000

```

在这个调用中，我们在[0；1]范围。

| ![](../Images/tip.png) | 提示:使用`linspace`时，您通常希望点数比要划分范围的零件数量多一个。例如，如果要将一个范围分成 100 个部分，请考虑指定 101 个点。 |

## 二维数组

现在让我们继续二维数组。这样的数组可以用空格组合来初始化。例如，为了创建矩阵![](../Images/image024.png)，我们写道:

```
    >> g = [1 2;3 4]

    g =
         1     2
         3     4

```

制作好矩阵后，我们可以使用`size`功能测量其尺寸:

```
    >> size(g)

    ans =
         2     2

```

同样，MATLAB 有创建二维数组的特殊功能。首先是`zeros`函数，它创建一个零初始化矩阵:

```
    >> zeros(3,2)

    ans =
         0     0
         0     0
         0     0

```

请注意，指定维度时，首先指定行数(3)，然后指定列数(2)。如果您只指定了一个参数，那么这个参数将用于*和*两个维度——换句话说，`zeros(3)`创建一个 3x3 数组。功能`zeros`也有其对应的名称`ones`。我让读者自己去弄清楚它创造了什么样的矩阵。并且，类似于这些，函数`inf`、`nan`和`rand`，当提供大小参数时，创建相应地用无穷大、NaN 和随机值填充的矩阵。

稍微往前跳一点，重要的是要意识到`zeros`这样的函数可以创建任意维度的数组。我们在上面制作了一个 2D 数组，但是我们可以通过提供一个维度数组作为函数的第一个也是唯一的参数来轻松创建一个三维数组:

```
    >> zeros(2,3,2)

    ans(:,:,1) =
         0     0     0
         0     0     0
    ans(:,:,2) =
         0     0     0
         0     0     0

```

这段代码有效地创建了一个 2×3×2 的数组。不用担心；我们将很快进入多维数组。

同时，这里还有一个特殊的数组构建函数`eye`，它创建了一个身份矩阵:

```
    >> eye(3)

    ans =
         1     0     0
         0     1     0
         0     0     1

```

通过一个参数调用，它为我们创建了一个 3×3 的正方形数组。如果我们指定两个参数，它会创建一个矩形数组，除了对角线以外，所有地方都是零。

## 寻址、操作和切片

既然我们知道了如何创建数组，让我们来讨论操作数组的方法。让我们做一个从 1 到 100 的数组。(请注意，我们在这里用分号终止了语句，以抑制输出。如果我们没有这样做，我们将在命令窗口中得到 100 个数字。)

```
    >> x=1:100;

```

要获得数组的单个元素，只需写下数组的名称，后跟元素的索引。例如，为了得到数组的第一个元素 **x** ，我们写道:

```
        >> x(1)

        ans =
             1

```

| ![](../Images/note.png) | 注意:MATLAB 中的数组索引以 1 开头，而不是以 0 开头。 |

为了得到从位置 5 到位置 10 的所有元素，我们可以简单地写:

```
    >> x(5:10)

    ans =
         5     6     7     8     9    10

```

我们最终得到的是一个全新的六个元素的数组，对应于原始数组中的位置 5 到 10。

还有一个特殊的变量 end，可以用来指示数组的最后一个元素。例如，要获得数组的最后十个元素，我们可以写:

```
    >> x(end-9:end)

    ans =
        91    92    93    94    95    96    97    98    99   100

```

还可以通过指定前提条件来过滤数组元素。例如，这里有一种从 1 到 10 取所有奇数的方法:

```
    >> x = 1:10

    x =
         1     2     3     4     5     6     7     8     9    10

    >> y = x(mod(x,2) == 1)

    y =
         1     3     5     7     9

```

这个例子中发生了很多事情。首先，值得注意的是`mod`是一个*矢量化*函数，这意味着对于输入数组中的每个元素，它将在输出中生成同样多的元素。运算符`==`也非常乐意以矢量化的方式工作，依次应用于 mod 输出的每个元素。最后，由于比较的最终结果是一个逻辑值，这说明了索引到数组中的另一种方式:通过提供一组真/假值作为索引，我们过滤数组，只留下那些对应参数值为**真**的元素。

正如您可能已经猜到的，我们不仅可以访问数组的元素，还可以修改它们。改变一个元素很容易——你只需写下`x(10)=123`，这就是你第 10 个<sup>元素被改变了。但是，有趣的是，我们还可以通过提供一个新的数组来改变数组的子集(显然，大小必须匹配)。例如，为了颠倒数组前五个元素的顺序，我们可以写</sup>

```
    >> x(1:5)=5:-1:1

    x =
      Columns 1 through 14
         5     4     3     2     1     6     7     8     9    10    11    12    13    14
      (other columns omitted)

```

该操作本质上创建了一个从 5 到 1 的值范围，步长为-1，然后将这些值放在原始数组的位置 1 到 5。

2D 阵列的操作遵循非常相似的思路。考虑以下阵列:

```
    >> x = [1 2;3 4]

    x =
         1     2
         3     4

```

我可以使用两个索引(对应于它的行和列)来索引它的元素，或者我可以只使用一个索引，在这种情况下，按列顺序遍历数组(这意味着我们首先从上到下遍历第一列，然后遍历第二列，依此类推):

```
    >> x(2,1)

    ans =
         3

    >> x(3)

    ans =
         2
     >> x(1:end)

    ans =
         1     3     2     4

```

您还可以通过简单地将其他维度的说明符替换为`:`(冒号)运算符来获得 2D(或者实际上是 N-d，其中 N>1)数组的整行或整列，该运算符用于指示“不在乎”或“给我一切”的值。例如，为了得到第一行，我们写道:

```
    >> x(1,:)

    ans =
         1     2

```

这个调用本质上是说“从第 1 行和所有列给我一些东西。”这就是你得到的。不用说，对 2D 数组的修改方式与对 1D 数组的修改方式相同，因此要用值[5，6]替换第一列，您可以编写:

```
    >> x(:,1) = [5;6]

    x =
         5     2
         6     4

```

当涉及到从数组中移除元素时，一种可能是将您想要移除的元素设置为`[]`，这是一个空数组:

```
  x =
      1    2    3    4

  >> x(3) = []

  x =
      1    2    4

```

也可以用`diag`函数取矩阵的对角线。这里有一种相当复杂的方法来创建一个用 1 填充的列向量:

```
    >> diag(eye(3))

    ans =
         1
         1
         1

```

`diag`函数简化了对角矩阵的工作，实际上是双向的:你不仅可以取一个现有矩阵的对角线，还可以将一个矩阵除对角线之外的所有元素都为零的向量转化为:

```
    >> diag([1 2 3])

    ans =
         1     0     0
         0     2     0
         0     0     3

```

## 排序和整形

为了说明对数组中的元素进行排序的思想，我将使用 MATLAB 的`magic`函数制作一个 5×5 的幻方:

```
    >> z = magic(5)

    z =
        17    24     1     8    15
        23     5     7    14    16
         4     6    13    20    22
        10    12    19    21     3
        11    18    25     2     9

```

万一你想知道，一个魔方有一个属性，它的所有行和列都有元素，加起来是同一个数字。不过，我们不会在演示中利用这个属性，而是让我们尝试对数组进行排序。为了对数组中的每一列进行排序，我们可以简单地使用`z`作为`sort`函数的参数:

```
    >> sort(z)

    ans =
         4     5     1     2     3
        10     6     7     8     9
        11    12    13    14    15
        17    18    19    20    16
        23    24    25    21    22

```

现在每一列都按顺序出现。然而，如果我们想要对每一行进行排序，我们需要在我们对`sort`的调用中明确指定要排序的维度:第二个参数值 1 表示行，2–列。

```
    >> sort(z,2)

    ans =
         1     8    15    17    24
         5     7    14    16    23
         4     6    13    20    22
         3    10    12    19    21
         2     9    11    18    25

```

这给了我们一个矩阵，其中每行的值以升序出现。

现在，假设我们有两个简单的数组:

```
    >> x = [1 2];
    >> y = [3 4];

```

我们可以将这两个数组合并成一个数组。为了将这两个数组连接在一起，我们简单地创建一个新的数组，其中`x`和`y`作为其元素:

```
    >> [x y]

    ans =
         1     2     3     4

    >> [x;y]

    ans =
         1     2
         3     4

    >> [x y;y x]

    ans =
         1     2     3     4
         3     4     1     2

```

请注意，在最后一个示例中，我不止一次地将原始数组包含在新数组中。这是完全合法的，只会导致源数组内容的重复。

现在，假设你想放大一个数组。你会怎么做？最简单的方法是分配一个还不存在的矩阵元素——这会立即重新调整数组以适应新的值:

```
    >> whos x

      Name      Size            Bytes  Class     Attributes
      x         1x2                16  double             

    >> x(3,3) = 12

    x =
         1     2     0
         0     0     0
         0     0    12

    >> whos x

      Name      Size            Bytes  Class     Attributes
      x         3x3                72  double

```

从输出中可以看到，当添加新元素时，1×2 数组神奇地被调整为 3×3 数组。

如果需要缩小数组，只需取一片即可！例如，要返回到原始数组，我只需要获取第一行的前两个列元素:

```
    >> x(1,1:2)

    ans =
         1     2

```

MATLAB 还有一套非常具体的矩阵运算，比如能够将矩阵旋转 90 度:

```
    >> z = eye(3);
    >> rot90(z)

    ans =
         0     0     1
         0     1     0
         1     0     0

```

最后，但肯定不是最不重要的，MATLAB 有一个`reshape`功能。该函数通过迭代数组的维度，然后将数组重新整形为您指定的任意多个维度，从而将数组视为一维数组。自然，原始数组和请求数组中的元素数量必须匹配:

```
    >> x = magic(4);
    >> reshape(x,2,8)

    ans =
        16     9     2     7     3     6    13    12
         5     4    11    14    10    15     8     1

```

例如，这段代码采用了一个 4×4 的幻方，并将其重塑为一个 2×8 的数组。同样，我们可以很容易地将正方形重塑为例如 1×16 阵列或 2×4×2 阵列。

与`reshape`函数一样，也可以通过用单个冒号来寻址元素，从而将矩阵转换为列向量:

```
    >> x = magic(2)
    x =
         1     3
         4     2

    >> x(:)
    ans =
         1
         4
         3
         2

```

当然，这不应该特别令人惊讶:我们已经提到多维数组可以用单个值进行索引，因此获得所有值的结果应该不会出乎意料。

## 换位和倒置

换位是一种非常常见的矩阵运算。本质上，它沿着对角线反映矩阵，所以每个元素交换它的行和列位置。严格来说，MATLAB 有一个为此定义的`transpose`函数，但是使用单个破折号( **'** )来实现完全相同的目的要容易得多(假设非复杂数据):

```
    >> x = [1 2;3 4]

    x =
         1     2
         3     4

    >> x'

    ans =
         1     3
         2     4

```

换位对于定义列向量也很有用，因为默认情况下`x:y`符号会给你一个行向量:

```
    >> (1:5)'

    ans =
         1
         2
         3
         4
         5

```

注意上面圆括号的用法——`'`运算符的优先级高于`:`，所以不能写`1:5'`，因为它实际上是`1:5'`的意思。

另一种常见的运算是矩阵求逆，给定一个矩阵![](../Images/image012.png)就得到一个满足关系![](../Images/image026.png)的矩阵![](../Images/image012b.png)(其中![](../Images/image027.png)为单位矩阵，`eye`)。通过使用`inv`函数或取原始矩阵的-1 次方来求逆矩阵:

```
    >> x = [-1 1;0 1];
    >> x^-1

    ans =
        -1     1
         0     1

    >> ans*x

    ans =
         1     0
         0     1

```

## 元素操作符

元素操作符是在 MATLAB 中处理矩阵的核心。用一个例子来说明他们的目的是什么最好的方法。让我们制作两个 2×2 矩阵:

```
    >> x=[1 2;3 4];
    >> y=[5 6;7 8];

```

现在，表达式`x*y`暗示了根据线性代数矩阵乘法规则的两个矩阵的乘法(矩阵维数当然应该一致)，但是如果你只想让`x`中的每个元素乘以`y`中相应的元素(也称为哈达玛乘积)会怎么样呢？这就是 elementwise 运算符的用途。本质上，我们要做的就是放一个句号(**)。**)前面是乘法运算符，下面是我们得到的结果:

```
    >> x.*y

    ans =
         5    12
        21    32

```

Elementwise 操作符在处理任何类型的数据集时都很重要，并且需要额外的例子。例如，假设我们将 100 美元存入银行账户，年利率为 5%。现在我们想知道 1 点以后我们会有多少钱..十年了。我们的第一个诱惑是写一些像这样的东西:

```
    >> 100*(1+0.05)^(1:10)

    Error using  ^
    Inputs must be a scalar and a square matrix.
    To compute elementwise POWER, use POWER (.^) instead.

```

但是正如您所看到的，我们不能将标量值乘以数组的幂——这个操作根本没有任何意义！我们需要做的是用它的 elementwise 版本替换 power 运算符，以便我们的标量值依次提升到每个幂:

```
    >> 100*(1+0.05).^(1:10)

    ans =
      Columns 1 through 5
            105.00        110.25        115.76        121.55        127.63
      Columns 6 through 10
            134.01        140.71        147.75        155.13        162.89

```

好多了。

## 求解线性方程组

矩阵的一个常见用途是用来求解线性方程组。例如，考虑这组等式:

![](../Images/image028.png)
![](../Images/image029.png)

我们可以用矩阵的形式![](../Images/image030.png)来表示这个方程，其中 A 是乘数的矩阵，B 是结果的矩阵:

MATLAB 为我们提供了使用`linsolve`函数求解该系统的选项。我们需要做的就是输入系数:

```
    >> a = [1,1; 1,-1]

    a =
         1     1
         1    -1
    >> b
b =
        10
         4

    >> linsolve(a,b)

    ans =
         7
         3

```

现在我们要去见另一个接线员！我们已经将它视为反向除法运算符，但是也求解等式![](../Images/image030.png)的特定于数组的 **\** (反斜杠)运算符可以通过使用高斯消去法而不产生矩阵的逆来提高效率。因此，它比计算`inv(a)*b`更快:

```
    >> a\b

    ans =
         7
         3

```

## 稀疏矩阵

除了普通矩阵，MATLAB 还支持稀疏矩阵。这些通常是大型矩阵，只有很小百分比的非零条目。稀疏矩阵是通过向`sparse`函数提供三个数组来定义的，这三个数组包含元素的坐标(一个数组用于 **i** ，另一个数组用于 **j** )以及元素值本身:

```
    >> i = [2,4,6];
    >> j = [1,3,5];
    >> v = [-1 200 33.7];
    >> sparse(i,j,v)

    ans =
       (2,1)      -1.0000
       (4,3)     200.0000
       (6,5)      33.7000

```

稀疏矩阵也可以通过`full`函数转化为适当的完全指定的矩阵:

```
    >> full(ans)

    ans =

             0         0         0         0         0
       -1.0000         0         0         0         0
             0         0         0         0         0
             0         0  200.0000         0         0
             0         0         0         0         0
             0         0         0         0   33.7000

```

一个有用的命令是`spy`，它通常可以计算出数组中发生了什么。此命令允许您在图形上可视化数组中的元素，对于查看稀疏矩阵特别有用。例如，监视一个 4×4 的身份矩阵会给我们以下图表:

![](../Images/image031.jpg)

图 10:在 4×4 身份矩阵上使用间谍命令。

你可能已经猜到了，点代表非零元素，而零代表不了任何点。还要注意对应矩阵元素位置的`x`和`y`坐标。哦，确保你没有忘记争论——如果你只是输入`spy`，你将会有一个惊喜。

## 更高的维度

正如你可能已经猜到的，维度高于 2 的数组不能在二维计算机显示器上有效地表示，但这并不意味着我们不能使用它们。

制作三维数组最简单的方法是使用一个获取数组维度参数的函数。例如，我可以使用`reshape`函数创建一个包含八个值的数组，并将它们塑造成一个 2×2×2 的数组:

```
    >> reshape(1:8, [2 2 2])

    ans(:,:,1) =
              1.00          3.00
              2.00          4.00
    ans(:,:,2) =
              5.00          7.00
              6.00          8.00

```

请注意视觉表示:由于三维数组不能在 2D 空间中有效地表示，我们可以依次看到它的每个 2D 切片。

其他 MATLAB 函数，如`ones`、`zeros`，以及各种随机数生成器也允许您指定正在生成的矩阵的维度。

创建二维以上矩阵的另一种方法是在现有的 2D 矩阵上增加一个额外的维度。例如，您可以从 2×2 矩阵开始:

```
    >> x = [1 2;3 4]

    x =
              1.00          2.00
              3.00          4.00

```

现在，你可以简单地将另一个 2×2 矩阵“拼接”到`x`的第三维度:

```
    >> x(:,:,2) = [4 5;6 7]

    x(:,:,1) =
              1.00          2.00
              3.00          4.00
    x(:,:,2) =
              4.00          5.00
              6.00          7.00

```

可以想象，这里概述的方法也适用于更高的维度。