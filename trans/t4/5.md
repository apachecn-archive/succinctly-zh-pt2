# 五、一切都关于元数据

元数据是关于数据的数据。在这里，数据将驱动代码生成。这是描述我们想要生成的代码的数据。确切地说，元数据驱动代码生成。

## 保持元数据干净

如果您的代码生成方法依赖于能够按需重新生成，那么您必须保护您的元数据。你要确保它保持最新和干净。如果没有适当的照顾，这两个目标可能会相互冲突。我们将讨论有助于管理这一争论的策略。我们还将很快看到，我们将使用两种类型的元数据。

内在元数据是我们真的不必担心更新的元数据。这些数据保持最新，无需我们额外的努力。例子包括反射，每次编译时编译器将保持最新的数据，以及 RDMS 将为我们保持最新的数据库数据字典。第 7 章将集中讨论反射，第 6 章将集中讨论数据字典

外在的元数据需要我们做更多的工作。这是我们可能专门为代码生成创建的元数据，或者它可能已经存在以支持系统的其他部分。关键是我们需要一个外部过程来更新和确保它是最新的和准确的。这里的示例通常是特定于领域的，并且通常在很大程度上取决于业务需求。

## 保持生成的代码干净

如果您的开发过程基于能够按需重新生成代码，您还必须保持生成的代码干净。这意味着确保对代码的任何更改要么被合并到将来的重新生成中，要么被保护以免在将来的重新生成中丢失。

我们有几个策略来确保代码变化在再生过程中持续存在。最简单的是更新用于驱动代码生成的元数据，但有时这还不够。我们可能还需要更新用于生成代码的模板。

例如，我们可以通过更新元数据来轻松地更改为实体框架实体生成的代码。向表中添加一列，相应的实体将获得一个新属性。与其添加属性，不如先更新元数据，让代码生成更新代码。

或者，我们可以决定将 **`IsVisible`** 属性添加到 **`ViewModel`** 的每个已定义属性中。这将是对驱动代码生成的模板的相对直接的改变。同样，我们不想直接对生成的代码进行这样的更改。相反，更新模板，让代码生成更新您的代码。

| ![](img/tip.png) | 提示:要记住的关键是不要直接更改代码生成过程中生成的文件。 |

有时，我们可能会对生成的代码进行“一次性”更改。这是一种不遵循模式的变化，在其他地方可能无法重现或需要。使用元数据或模板不容易做出或描述这样的改变。示例可能包括未映射到数据库的计算字段或特定于上下文的自定义验证逻辑。

即使在这些场景中，我们也不想直接操作生成的代码。这并不意味着我们不能改变代码。我们不能更改由代码生成创建的输出文件中的代码，但是由于部分类，我们可以忍受这种限制。

| ![](img/tip.png) | 提示:始终将生成的类标记为部分类，以便实现可以分布在多个文件中，实际上只有一个文件是禁止的。我们可以自由地向类定义中添加一个新文件，并在那里进行任何需要的更改。 |

## 查找元数据

生成代码的最初挑战是找到元数据。幸运的是。NET 是关于元数据的。我们通过反射来访问这些元数据。我们将在第八章进一步探讨反思。现在，我们将简单地提到反射使我们能够访问关于程序集中类型的所有数据。

### 倒影

使用反射，我们可以加载一个程序集并搜索该程序集中的类型。对于任何类型，我们都可以搜索它的属性、事件和方法。对于任何方法，我们都可以遍历参数并检查返回类型。

这让我们获得了很多信息。在第 7 章中，我们将逐步介绍展示如何访问这些数据的代码，并探索使用这些信息来驱动代码生成的一些选项。

### 数据字典

每个数据库中的数据字典都是元数据的另一个重要来源。无需您的任何干预，关系数据库管理系统(RDMS)会跟踪每个表、每个表中的每一列、每个存储过程和这些存储过程的每个参数的元数据，以及数据库中每个关系和约束的详细信息。RDMS 跟踪更多的元数据只是为了保持数据库的运行，但是这些是我们在代码生成中关心的主要元数据类型。数据库是非常元数据密集型的，数据字典是这种元数据的关键。

在第 6 章中，我们将探讨 SQL Server 管理对象(SMO)库，它为访问这些数据提供了一个丰富的对象模型。

### 代码模型

代码模型是由 Visual Studio 提供的一个 API，用于在编译代码之前遍历 Visual Studio 中的代码。它让我们可以访问通过反射获得的相同数据，而不必先编译成程序集。

众所周知，代码模型是一个很难使用的应用编程接口，但是不要担心——我们将破译它的奥秘，并展示如何获得驱动代码生成所需的数据。

第 8 章将进一步探讨代码模型。