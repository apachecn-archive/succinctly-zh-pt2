# 第一章 OWIN

## 简介

在第一章中，你将学习网络开发的世界在过去几年里是如何发生巨大变化的。NET 开发人员定义了一小组规范，试图在。NET 世界更容易。您还将了解微软是如何接受这些规范的，以及为什么它将 ASP.NET 的未来建立在这些规范的基础上。

网络发展很快，网络开发需要跟上它。出于这个原因，所有框架供应商都需要为开发人员提供好的解决方案来处理他们的最新需求。

其中一个需求是在 web 应用程序和 web 服务器之间有一个抽象。这有几个优点，我们将在本书后面讨论。

[O](http://owin.org/) WIN 在网络应用和网络服务器之间架起了一座桥梁。NET 世界，提供不同的解决方案，如[卡塔纳](http://katanaproject.codeplex.com/)或开源社区驱动的 [Nowin](https://github.com/Bobris/Nowin) 。

## 什么是 OWIN？

OWIN 是开放网络服务器接口的缩写。NET 。在[项目网站](http://owin.org/)上定义如下。

OWIN 定义了一个标准接口。网络服务器和网络应用程序。OWIN 接口的目标是分离服务器和应用程序，鼓励开发简单的模块。NET 网络开发，并且通过成为一个开放标准，刺激了。NET 网络开发工具。

看完定义可以想象，OWIN 没有代码，只有[规范](http://owin.org/spec/spec/owin-1.0.0.html)来实现一个定制的 web 服务器。

两年后(2010-2012 年)，OWIN 的规范终于完成，目前的版本是 1.0。如果您好奇并想查看规范的历史，[草案历史](http://owin.org/spec/spec/history-1.0.html)也可在 OWIN 项目网站上获得。

## 我们为什么需要 OWIN？

你可能已经找到了一些使 OWIN 成为网络应用程序中一个重要因素的原因，但是还有一些不太明显的原因。

首先，OWIN 的目标是为网络服务器定义一个标准接口。NET 客户端应用程序进行交互，而 Katana 和 Nowin 是实现。

此外，正如 OWIN 网站所说，OWIN 的设计灵感来自于 Python 上的 [Node.js](http://nodejs.org/) 、[WSGI](http://wsgi.readthedocs.org/en/latest/index.html)和 [Rack](http://rack.github.io/) ，这是一个类似 Ruby 的轻量级服务器。

尽管 Node.js 和 OWIN 有很多相似之处，但也有一些重要的区别:OWIN 规范提到了一个 web 服务器，就像在服务器上运行的东西，它响应 HTTP 请求，并将它们转发给它的中间件。另一方面，Node.js 是运行在您的代码下的 web 服务器，因此您可以完全控制它。

那么，为什么 OWIN 这么酷，为什么我们需要它？

嗯，互联网信息服务(IIS)是一个超级测试的网络服务器，它可能会有很长的寿命。NET 应用程序，但它有几个限制。

首先，IIS 与操作系统有关。这意味着您必须等待新版本的 Windows 有新的功能(例如，网络套接字仅在最新版本的 Windows 上可用)。你必须完全更新网络服务器。通常更新网络服务器并不容易，系统管理员不喜欢像“我需要最新版本的 Windows，因为我需要使用网络套接字”这样的请求

对于 OWIN，您的代码与操作系统(特别是系统)无关。Web，ASP 执行背后的“巨大”整体库。NET)。这意味着您可以使用任何您想要的东西来代替 IIS(即 Katana 或 Nowin)，并在必要时更新它，而不是更新操作系统。此外，如果您需要它，您可以构建您的自定义主机，并在 HTTP 请求处理管道中插入您想要的任何东西(即您的自定义身份验证逻辑)。

所有这些都是可能的，这要归功于 OWIN，他提供了编写那些“扩展点”的规范，使得它很容易插入到链中。在一个完美的世界里，所有的网络服务器都在观察 OWIN，你也可以改变网络服务器，保持你的扩展点而不需要写一行代码。

另一个要点可能是性能，但我们将在稍后讨论管道时解释它。

## 什么时候使用 OWIN 是正确的？

简短的回答是:*“只要你使用的框架允许。”*

这是因为 OWIN，尤其是卡塔纳，正在成为微软网络开发堆栈的一部分(随着 ASP.NET 虚拟文本将于 2015 年到期，这将更加真实)。一些框架整合了 OWIN 的范例，而另一些还不兼容。比如 Web API 和 SignalR 兼容 OWIN，可以在 OWIN 中间件管道中使用，而 ASP.NET MVC(V5 之前)仍然不兼容。Nancy、FubuMVC 和其他第三方网络框架也与 OWIN 兼容。在[第三章](3.html#_Chapter_3_)中，我们将看看如何将这些框架与武士刀一起使用。

兼容性的问题不会持续很久，因为新一轮的 ASP.NET 网络框架将基于 OWIN，包括新版本的 ASP.NET MVC(V6)。很快你将使用建立在 OWIN 规范之上的软件，即使你不知道它。ASP.NET MVC 的一些当前版本也是基于 OWIN 的，正如你将在[第 5 章](5.html#_Chapter_5_)中看到的。

## OWIN 规格

现在，我们已经了解了什么是 OWIN，以及尊重 OWIN 规范的服务器在哪些情况下是有用的，现在是详细分析规范的时候了。

正如本章开头所预期的，OWIN 规范非常简单。它们定义了一组层、它们的堆叠顺序和接口，称为应用程序委托或`AppFunc`，由这些层用来相互通信。

### 图层

![Owin Layers](../Images/image001.jpg)

图 1: OWIN 图层

OWIN 规范定义了四层:

*   **主机**:执行所有其他层的过程。它主要负责进程的应用配置和启动，包括启动服务器。
*   **服务器**:这是*实际的* HTTP 服务器，绑定到网络套接字监听请求并发送到 OWIN 中间件组件管道的服务器。
*   **中间件**:这些直通组件位于服务器和最终应用程序代码之间，处理通过 OWIN 管道发送的请求。这些组件可以像记录器一样简单，也可以像网络应用编程接口或信号器这样的完整网络框架一样复杂。就服务器而言，中间件组件是实现应用程序委托的任何东西。
*   **应用**:这是具体的应用代码，可能建立在 web 框架之上。由于应用程序的代码将只与 web 框架交互，因此您与管道的 OWIN 部分的唯一交互将是管道的配置，但仅此而已。

### 申请代表

规范的另一个重要部分是中间件组件用来与 OWIN 管道中的服务器交互的接口的定义。它不是严格意义上的接口，而是每个 OWIN 中间件组件应该提供的一个委托。

```
     using AppFunc = Func<
      IDictionary<string, object>, // Environment
      Task>; // Done

```

代码清单 1

简单地说，前面的代码意味着每个 OWIN 中间件必须有一个方法，该方法接收一个类型为`IDictionary<string, object>`(称为环境字典)的变量作为输入，该变量具有运行请求的状态，并且必须返回一个`Task`对象，以允许组件的异步执行。

### 环境词典

环境字典包含关于请求、响应对象和任何服务器状态的所有信息。服务器的责任是创建字典，用用于编写响应的流填充它，并读取可能的带有所有头的请求体。

通过管道，每个组件和层可以添加额外的数据，但是规范定义了一组必须始终存在的强制键。

表 1:请求数据中的强制键

| 键名 | 描述 |
| --- | --- |
| 打包申请表格 | 带有请求正文的`Stream`(如果有)。`Stream.Null`如果没有请求正文，可以用作占位符。 |
| 哎呀。请求标题 | 请求标题的`IDictionary<string, string[]>`。 |
| owin.RequestMethod(请求方法) | 一个`string`，包含请求的 HTTP 请求方法(如 GET、POST)。 |
| 哎呀。请求路径 | 一个包含请求路径的`string`。路径必须相对于应用程序委托的根。 |
| 奥云！RequestPathBase | 一个`string`，包含对应于应用程序委托根的请求路径部分。 |
| 奥云！RequestProtocol(请求协议) | 一个包含协议名称和版本(如 HTTP/1.0 或 HTTP/1.1)的`string`。 |
| 奥云！RequestQueryString | 一个`string`包含 HTTP 请求 URI 的查询字符串组件，没有前导“？”(例如，“foo=bar & baz=quux”)。该值可以是空字符串。 |
| 奥云！RequestScheme(请求方案) | 包含用于请求的 URI 方案的`string`(例如，http，https)。 |

表 2:响应数据中的强制键

| 键名 | 描述 |
| --- | --- |
| 奥文.回答我 | A `Stream`用于写出响应体，如果有的话。 |
| 奥云！回答我 | 响应报头的`IDictionary<string, string[]>`。 |
| 哎呀。响应状态代码 | 可选的`int`，包含 [RFC 2616 第 6.1.1 节](https://www.ietf.org/rfc/rfc2616.txt)中定义的 HTTP 响应状态代码。默认值为 200。 |
| 哦。ResponseReasonPhrase | 可选的`string`包含与给定状态代码相关的原因短语。如果未提供，则服务器应提供默认设置，如 [RFC 2616 第 6.1.1 节](https://www.ietf.org/rfc/rfc2616.txt)所述。 |
| 哦。响应协议 | 包含协议名称和版本的可选`string`(例如 HTTP/1.0 或 HTTP/1.1)。如果没有提供，那么 owin。RequestProtocol 键的值是默认值。 |

表 3:其他强制键

| 键名 | 描述 |
| --- | --- |
| 哎呀。呼叫已取消 | 指示请求是否已被取消或中止的`CancellationToken`。 |
| 奥云！版本 | `string` 1.0 表示 OWIN 版本。 |

### 应用程序启动

规范，特别是[第 4 节](http://owin.org/spec/spec/owin-1.0.0.html#_4._Application_Startup)，还定义了启动顺序，以及新的中间件应该如何添加到应用程序中。直到几个月前，OWIN 小组还提供了一个非规范的`IAppBuilder`来形式化 OWIN 管道如何启动以及如何添加中间件，但最近它被删除了，因为这个话题仍在邮件列表中讨论。预计将来这部分规格会有变化。

### 规格的一般考虑

这些规范看似很小，但其重要性在于它们的简单性:通过要求基本上只依赖一种类型(T0)，它们降低了想要编写 OWIN 组件的开发人员的入门门槛。此外，使用字典允许组件和框架之间的互操作性，而不需要所有不同的开发人员就特定的结构化对象模型达成一致，这是非常难以实现的。微软构建的三种不同的网络框架——网络表单、ASP.NET MVC 和网络应用编程接口——有三种不同的对象模型来维护当前请求的状态。

## 介绍武士刀

正如我们刚刚看到的，OWIN 只是一些规格。为了使它们在实际项目中可用，必须有一些东西来实现它们。在撰写本文时，只有两款公开发布的服务器实现了这些规格:由微软开发的 Katana 和 Nowin。在本书的其余部分，我们将在每次需要引用具体实现时使用武士刀实现。

### 武士刀简史

在看如何使用武士刀之前，我们需要通过回顾 10 多年来 ASP.NET 的演变来了解它是如何形成的。

#### ASP.NET 网络表单

第一个是 2001 年的 ASP.NET 网络表单，它是针对两类开发人员构建的:

*   来自 ASP Classic 的开发人员，他们习惯于混合使用 HTML 标记和服务器端脚本来构建动态网站。此外，ASP 运行时抽象了底层的 HTTP 连接和 web 服务器，并向开发人员提供了一组对象，允许他们轻松地与当前的 HTTP 请求进行交互。它还提供了额外的服务，如会话管理、状态、缓存等。
*   来自更传统的 Windows 窗体应用程序开发的开发人员。这些开发人员不知道如何编写 HTML，并且习惯于通过在设计画布上拖动元素来构建应用程序。

为了迎合这两类开发人员，第一个名为网络表单的 ASP.NET 网络框架的目标是用服务器端事件模型隐藏网络的无状态特性，主要通过臭名昭著的视图状态实现。

结果是成功的，有一个功能丰富的 web 框架和可接近的编程模型。但所有这些都有一些局限性:

*   所有的特性都是在一个整体框架中一起发布的，与核心的网络抽象库 System.Web 紧密结合
*   由于在很大程度上基于设计时编程模型，ASP.NET 被绑定到更大的。NET 框架，也可以移植到 Visual Studio 这意味着，除了快速修复之外，web 框架的发布间隔了好几年。
*   最后但同样重要的是，ASP.NET 框架(通过其核心库系统。网络)也只能与微软的互联网信息服务网络服务器连接使用。

#### ASP.NET 最有价值球员

随着时间的推移，这些限制开始时似乎并不十分危险，但现在开始显示出它们的成本。对于微软来说，适应其他框架和语言的快速发展变得非常困难，这些框架和语言是作为小型且非常集中的组件而不是大型框架构建的。

此外，网络开发的风格也发生了变化:虽然最初让框架抽象掉 HTTP 甚至 HTML 标记有助于非网络开发人员构建网络应用程序，但现在开发人员想要更多的控制，尤其是对页面上呈现的标记。

为了解决这两个问题，ASP.NET 团队开发了 ASP.NET MVC 框架，采用模型-视图-控制器设计模式来保持业务逻辑和表示逻辑之间的清晰分离，同时允许开发人员完全控制标记。此外，他们决定带外发布框架，不与耦合。NET 框架，使得更快、更频繁的发布成为可能。

一些问题仍然存在，最明显的是对庞大系统的依赖。网络动态链接库，这使得 ASP.NET MVC 不完全独立于更大的。NET 框架。

#### ASP.NET 网络应用编程接口

几年后，web 应用程序的构建方式发生了另一个重大变化。应用程序不是由服务器生成的数据驱动页面，而是被构建为大部分静态页面，其中一些部分是通过 AJAX 调用与 web APIs 交互生成的。

ASP.NET 团队开始构建一个新的框架，称为 ASP.NET 网络应用编程接口，以更好地接近这种网络开发模式。他们还抓住机会，通过摆脱对系统的依赖，朝着更加模块化的组件模型发展。Web 和构建一个可以独立于 ASP.NET 其他地方发展的框架，并且由于最近引入了 NuGet，这是一个包管理器。NET 库很容易安装。除此之外，因为它不依赖于系统。它也不依赖于 IIS，允许在自定义主机和其他网络服务器上运行。

#### 卡塔纳来了

随着网络应用编程接口能够在自己的轻量级主机上运行，以及更加模块化和更加专注的框架的增长，存在着开发人员必须启动单独的进程来处理现代网络应用程序的各种组件的具体风险，例如静态文件、动态文件、网络应用编程接口和网络套接字。

为了避免进程的激增，所有这些进程都需要独立地启动、停止和管理，需要一个公共的托管进程，可以很容易地向其中添加额外的特性和模块。

这就是为什么 OWIN 诞生了，来标准化框架和组件可以很容易地插入那些托管过程的方式。Katana 是微软在这些规范之上构建的托管流程和服务器。

### 如何获得武士刀

Katana 是带外发行的，作为一个 NuGet 包提供，你可以直接包含在你的项目中。

在下一章中，我们将看到如何创建您的第一个运行在 Katana 上的简单网络应用程序。

## 许可证

像所有其他开源项目一样，OWIN 和卡塔纳有一个许可证，当你想使用它们时，你必须遵守它。

幸运的是，所使用的许可证是 Apache License 2.0，它非常宽松，基本上赋予了您以任何方式使用软件的权利，只要:

*   保留原版权。
*   许可证包含在修改后的软件中。
*   如果对软件进行了重大更改，必须在某个地方说明。

## 结论

在这一章中，你已经了解了什么是 OWIN，OWIN 是如何形成的，以及 OWIN 的规格是什么。

你简要回顾了微软网络开发栈的历史，为什么现在是微软接受 OWIN 规范的合适时机。微软已经建立了自己的名为 Katana 的实现，并计划在 OWIN 的基础上建立未来的网络开发平台。

在下一章中，您将了解什么是卡塔纳，它的组件如何映射到 OWIN 规格，以及如何在卡塔纳上开始为您构建第一个“你好，世界”网络应用程序。