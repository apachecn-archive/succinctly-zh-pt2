# 简介

这是一本关于微软 Unity、微软实现控制反转(IoC)、依赖注入(DI)和面向方面编程(AOP)容器和库的书。Unity 是企业库的一部分，企业库是应用块的集合，包含核心中没有的特性。NET 框架，但是在编写企业应用时通常非常有用。

那么，现在我们已经听到了流行语，Unity 到底是用来做什么的呢？好吧，Unity 通过遵循被称为 [SOLID(单一责任、开-闭、利斯科夫替换、接口分离和依赖反转)](http://en.wikipedia.org/wiki/Solid_(object-oriented_design))的设计原则来帮助我们编写解耦的应用，具体来说，**利斯科夫替换原则**规定:

"程序中的对象应该可以用它们的子类型的实例替换，而不改变程序的正确性."

和**依赖倒置原则**:

“一个人应该依靠抽象。不要依赖于具象。”

这两个原则告诉我们的是，我们应该通过定义其契约的接口或抽象基类来公开包含业务逻辑的类，并根据这个契约编写我们的程序。这样，我们就可以避免任何可能发生的实现更改，并且可以将一个实现完全更改为另一个实现。因此，我们正在将具体的实现从它们的契约中分离出来，并最小化代码之间的依赖性，这最终使得程序更容易维护和理解。

Unity 到底是如何做到这一点的？我们为业务层中那些更有可能改变或有不同实现的部分注册合同，并将它们映射到具体的实现中。在代码中，我们向 Unity 请求这些契约的实现，并不关心该实现来自哪里或者它到底是什么(当然，我过于简化了，但是我认为您已经了解了)。

除此之外，Unity 还帮助我们管理复杂的组件依赖关系。假设您有一个应该用某种类型的属性初始化的类。这种类型需要在其构造函数中接收许多参数，并且在创建之后，需要调用一个初始化方法。构造函数参数本身也是复杂类型，等等。明白我的意思吗？事情会变得非常复杂。Unity 允许我们定义创建每一个组件的规则，并将它们注入适当的位置，以便一切就绪。

最后，Unity 还有助于将交叉行为应用到我们的代码中。这不是实际的业务逻辑，而是助手功能，它允许我们只编写代码来完成它应该完成的核心任务，并拥有访问控制、日志记录、异常处理等功能。，自动应用。

希望在这本书里，你能理解 Unity 是如何帮助我们做到这一切的。最后，我将谈谈 Unity 如何与现代微软堆栈技术集成。