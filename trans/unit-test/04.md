# 四、实现单元测试的策略

测试方法取决于你在项目中的位置和你的“预算”，包括时间、金钱、人力、需求等。理想情况下，单元测试被编入开发过程的预算中，但实际上，我们经常会遇到现有的或遗留的程序，它们很少或没有代码覆盖，但必须升级或维护。最糟糕的情况是，一个产品目前正在开发中，但是在开发过程中出现了越来越多的失败，同样是很少或者没有代码覆盖。作为一个产品经理，无论是在开发工作的开始，还是作为一个已有应用程序的结果，开发一个合理的单元测试策略是很重要的。请记住，单元测试应该为您的项目提供可衡量的好处，以抵消其开发、维护和自身测试的责任。此外，您为单元测试采用的策略会影响应用程序的体系结构。虽然这几乎总是一件好事，但它可能会为您的需求引入不必要的开销。

## 从需求开始

如果您正在从头开始一个足够复杂的应用程序，而您手中掌握的只是一组需求，请考虑以下指导。

### 优先考虑计算需求

优先考虑应用程序的计算需求，以确定复杂性所在。复杂性可以通过发现特定计算必须适应的状态数量来确定，或者它可以是执行计算所需的大量输入数据的结果，或者它可以只是算法上的复杂，例如在卫星的冗余环上进行故障案例分析。还要考虑由于未知的需求变化，代码将来可能会在哪里发生变化。虽然这听起来像是需要先知先觉，但是一个熟练的软件架构师可以将代码分为通用的(解决一个常见的问题)和领域特定的(解决一个特定的需求问题)。后者成为未来变革的候选对象。

虽然为琐碎的函数编写单元测试是容易的、快速的，并且在程序大量的测试用例中是令人满意的，但是它们是最没有成本效益的测试——它们需要时间来编写，并且因为它们最有可能一开始就被正确地编写，并且它们最有可能不会随着时间的推移而改变，所以随着应用程序代码库的增长，它们是最没有用处的。相反，将您的单元测试策略集中在特定领域和复杂的代码上。

### 选择一个架构

从一组需求开始一个项目的好处之一是，您可以创建架构(或者选择第三方架构)作为开发过程的一部分。第三方框架允许您利用诸如控制反转(以及相关的依赖注入概念)之类的架构，以及诸如模型-视图-控制器(MVC)和模型-视图-视图模型(MVVM)之类的正式架构来促进单元测试，原因很简单，模块化架构通常更容易进行单元测试。这些体系结构分离出来:

*   演示文稿(视图)。
*   模型(负责持久性和数据表示)。
*   控制器(应该进行计算的地方)。

虽然模型的某些方面可能是单元测试的候选者，但大多数单元测试可能是针对控制器或视图模型中的方法编写的，控制器或视图模型是实现模型或视图计算的地方。

### 维护阶段

即使您参与了一个应用程序的维护，单元测试也是有好处的，这个应用程序要么需要向现有的应用程序添加新的特性，要么只需要修复遗留应用程序的错误。对于现有的应用程序，有几种方法，这些方法背后的问题可以决定单元测试的成本效益:

*   你只为新特性和错误修复编写单元测试吗？特性或 bug 修复是会从回归测试中受益的东西，还是一次性的、孤立的问题，在集成测试中更容易测试？
*   你开始针对现有的特性编写单元测试了吗？如果是，您如何确定首先测试哪些特性的优先级？
*   现有的代码库在单元测试中工作得好吗？还是代码首先需要重构来隔离代码单元？
*   特性或错误测试需要什么设置或拆卸？
*   对于可能导致其他代码副作用的代码更改，可以发现哪些依赖关系，单元测试应该扩展到测试依赖代码的行为吗？

进入缺乏单元测试的遗留应用程序的维护阶段并不容易——对代码的规划、考虑和调查可能通常需要比简单地修复错误更多的资源。然而，明智地使用单元测试可能是有成本效益的，虽然这并不总是容易确定的，但是值得一试，如果没有其他原因，只是为了更深入地理解代码库。

## 确定你的流程

关于单元测试过程，有三种策略可供选择:“测试驱动开发”、“代码优先”，尽管这可能与本书的主题“无单元测试”过程相对立。

### 测试驱动开发

一个阵营是“测试驱动开发”，由以下工作流程总结:

给定一个计算需求(参见前面的部分)，首先，为该方法编写一个存根。

*   如果需要依赖尚未实现的其他对象(作为参数传递给方法或由方法返回的对象)，请将这些对象实现为空接口。
*   如果缺少属性，请为验证结果所需的属性实现存根。
*   编写任何安装或拆卸测试要求。
*   写测试。在写测试之前写任何存根*的原因是:第一，写测试时利用 IntelliSense 第二，确定代码仍然可以编译；第三，确保被测试的方法、它的参数、接口和属性在命名方面都是同步的。*
*   运行测试，验证它们是否失败。
*   对实现进行编码。
*   运行测试，验证它们是否成功。

实际上，这比看起来更难。很容易成为编写不具成本效益的测试的牺牲品，人们经常会发现，被测试的方法不是一个足够细粒度的单元，实际上不适合作为测试的候选。也许该方法做得太多，需要太多的设置或拆卸，或者依赖于太多的其他对象，这些对象都必须初始化为已知状态。这些都是编写代码时更容易发现的东西，而不是测试。

测试驱动方法的一个优点是这个过程灌输了单元测试的原则，并且首先编写单元测试。很容易确定开发人员是否在遵循这个过程。通过实践，一个人可以变得容易，也可以使这个过程具有成本效益。

测试驱动方法的另一个优点是，就其本质而言，它实现了一种架构。编写一个单元测试来初始化一个窗体，将值放入一个控件，然后调用一个方法来对这些值执行一些计算，这是荒谬但可行的，因为这段代码需要(实际上在这里找到了):

```cs
    private void btnCalculate_Click(object sender, System.EventArgs e)
    {
      double Principal, AnnualRate, InterestEarned;
      double FutureValue, RatePerPeriod;
      int NumberOfPeriods, CompoundType;

      Principal = Double.Parse(txtPrincipal.Text);
      AnnualRate = Double.Parse(txtInterest.Text) / 100;

      if (rdoMonthly.Checked)
        CompoundType = 12;
      else if (rdoQuarterly.Checked)
        CompoundType = 4;
      else if (rdoSemiannually.Checked)
        CompoundType = 2;
      else
        CompoundType = 1;

      NumberOfPeriods = Int32.Parse(txtPeriods.Text);
      double i = AnnualRate / CompoundType;
      int n = CompoundType * NumberOfPeriods;

      RatePerPeriod = AnnualRate / NumberOfPeriods;
      FutureValue = Principal * Math.Pow(1 + i, n);
      InterestEarned = FutureValue - Principal;

      txtInterestEarned.Text = InterestEarned.ToString("C");
      txtAmountEarned.Text = FutureValue.ToString("C");
    }

```

前面的代码是不可测试的，因为它与事件处理程序和用户界面纠缠在一起。相反，我们可以写出复利计算方法:

```cs
    public enum CompoundType
    {
      Annually = 1,
      SemiAnnually = 2,
      Quarterly = 4,
      Monthly = 12
    }

    private double CompoundInterestCalculation(
      double principal,
      double annualRate,
      CompoundType compoundType,
      int periods)
    {
      double annualRateDecimal = annualRate / 100.0;
      double i = annualRateDecimal / (int)compoundType;
      int n = (int)compoundType * periods;
      double ratePerPeriod = annualRateDecimal / periods;
      double futureValue = principal * Math.Pow(1 + i, n);
      double interestEaned = futureValue - principal;

      return interestEaned;
    }

```

这将允许编写一个简单的测试:

```cs
    [TestMethod]
    public void CompoundInterestTest()
    {
      double interest = CompoundInterestCalculation(2500, 7.55, CompoundType.Monthly, 4);
      Assert.AreEqual(878.21, interest, 0.01);
    }

```

此外，通过使用参数化测试，可以直接测试每种复合类型、一系列年份以及不同的利息和本金金额。

测试驱动的方法实际上通过发现实际的可测试单元并将它们从边界跨越的依赖中隔离出来，促进了更形式化的开发过程。

### 代码第一，测试第二

首先编码更自然，因为这是开发应用程序的通常方式。乍看之下，需求及其实现似乎也足够容易，因此编写几个单元测试似乎是对时间的不充分利用。截止日期等其他因素会迫使项目进入“只需编写代码，我们就可以交付”的开发过程。

代码优先方法的问题在于，编写需要我们之前看到的那种测试的代码很容易。代码首先需要一个积极的纪律来测试已经编写的代码。这个规则难以置信地难以实现，特别是因为总是有下一个新特性要实现。

如果你愿意的话，这也需要智慧来避免编写纠缠不清、越界的代码，以及这样做的纪律。谁没有在 Visual Studio 设计器中单击一个按钮，并在 Visual Studio 为您创建的存根中编码事件的计算？这很简单，因为工具正指引你朝着那个方向前进，天真的程序员会认为这是正确的编码方式。

这种方法需要仔细考虑团队的技能和纪律，并且需要对团队进行更密切的监控，尤其是在高压力时期，纪律严明的方法往往会失效。诚然，随着最后期限的临近，一个测试驱动的规程也可能被抛弃，但这往往是一个有意识的例外决定，而它很容易成为代码优先方法中的规则。

### 无单元测试

仅仅因为你没有单元测试并不意味着你放弃了测试。可能只是测试强调验收测试程序或集成测试。

### 平衡测试策略

一个经济高效的单元测试过程需要在测试驱动开发、代码优先、测试优先和“测试其他方式”策略之间取得平衡。应该始终考虑单元测试的成本效益，以及团队中开发人员的经验等因素。作为一名经理，如果你的团队相当绿色，并且你需要这个过程来灌输纪律和方法，你可能不想听到测试驱动的方法是一个好主意。