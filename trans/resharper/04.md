# 第 4 章查找和编辑工具

你可能会想，为什么 R#有一整节专门用来找东西——毕竟，我们在上一章中介绍的大多数导航工具都是为此而设计的，对吗？

这里的答案其实是一个是，一个不是。为什么呢？导航工具的设计是为了让你快速高效地四处走动。在某种程度上，他们确实必须搜索东西，但这种搜索通常非常笼统，并且没有具体针对特定的时间点。

是的，你可以使用导航工具从一个方法跳到另一个方法，但是如果你不知道方法名或开始的地方呢？

这就是 R#的查找工具发挥作用的地方。

假设你在已经打开的标签之间跳来跳去，你不记得某个特定功能在哪个标签中，但你记得它以“abc”开头。大多数在 Visual Studio 中工作的开发人员都会本能地按 Ctrl+F 来调出查找。

R#的查找工具以类似的方式工作；它们是专门为寻找你不完全确定的东西而设计的。

### 寻找用法

在一个复杂的项目中，您可能有许多依赖的模块和层，尤其是如果您遵循 n 层风格的体系结构。表示层可能使用业务层，而业务层又可能使用数据层，所有东西都可能与安全层交叉——这是在我们开始全面考虑 MVC 项目中的属性和 NuGet 依赖关系之前。

例如，如果您有一个数据库，您可能想知道它用在解决方案的哪个部分。对于此任务，您可以使用“查找用法”选项。

将光标放在项目中任何地方的方法上。我在我的内部网应用程序中选择了一个类，它使用雅虎查询语言(YQL)来获取我所在地区的本地新闻。我想看看我的项目的哪些部分使用本地新闻提要，所以我右击方法声明，并从我的上下文菜单中选择**查找用法**:

![](../Images/image051.jpg)

图 49:从上下文菜单中选择查找用法

也可以通过点击 **ReSharper** > **查找** > **查找用法**来使用 Visual Studio 中的主 R#菜单。默认情况下，“查找用法”没有键盘快捷键设置，但与 R#中的其他所有设置一样，这可以在键盘选项中轻松更改。

您还会注意到还有一个查找用法高级菜单选项；如果你点击这个，你会看到一个完全不同的对话框:

![](../Images/image052.jpg)

图 50: R#高级查找用法对话框

默认情况下，“查找用法”工具仅在解决方案级别搜索基于代码的用法。“高级”对话框允许您更精确地进行搜索，并允许您执行诸如在注释中搜索和寻找动态用途等任务。

您也可以缩小范围，这样您就可以只搜索给定的项目，而不是搜索整个解决方案。您还可以查找方法的重载，这在使用大量抽象类时特别有用。

向下移动菜单将我们带到**查找依赖于模块**的代码。这个选项是为你们中的 NuGet 粉丝准备的。如果您展开任何项目的引用部分，并右键单击树中的任何引用，您将看到这个选项也出现在上下文菜单中，如图 51 所示:

![](../Images/image053.jpg)

图 51:直接从解决方案资源管理器查找依赖于模块的代码

当您选择此菜单选项时，R#将在您的引用中找到当前范围内引用所选模块的所有代码。

在图 51 中，我右键单击了我的数据访问层，因此一旦我单击左箭头按钮选择该选项，我将立即获得当前项目中引用该库的所有位置的列表:

![](../Images/image054.jpg)

图 52: R#搜索当前模块的引用

![](../Images/image055.jpg)

图 53:发生在图 52 中的搜索结果

一旦“查找结果”窗口出现，您就可以像任何其他面板一样将其停靠到 Visual Studio 环境中，双击任何条目都会将您直接带到源代码中的该位置。

多个搜索还会在同一个面板中打开多个搜索结果选项卡，因此您可以轻松搜索多个不同的包，然后保持列表打开以快速访问。

下一个选项**查找范围外的符号**，在项目级别最有效。如果使用正确，此选项将搜索并列出所选文件、模块或项目的任何外部引用。如果我们在我的内部网项目中的 WebUI 上尝试这样做，您将获得一个列表，其中列出了项目正常运行所依赖的(并且知道的)任何东西。

![](../Images/image056.jpg)

图 54:在网络用户界面项目中查找范围外符号的结果

正如您所看到的，我可以立即构建一个图片，确切地说明哪些引用被使用，哪些没有使用，这使我可以轻松地删除冗余链接，并促进更小、更快的构建。

**优化参考**选项就是为了做到这一点而设计的，这样我们就不用手动操作了。在解决方案资源管理器中右键单击项目的“引用”分支，然后选择**优化引用**。过一会儿，你会得到一份报告，确切地显示哪些引用被使用和不被使用，那些被使用的引用如何适应大局，以及 R#认为哪些引用可以删除。结果应该如图 55 所示:

![](../Images/image057.jpg)

图 55: R#优化引用报告

然后，您可以使用报告顶部的各种工具来组织和执行 R#的建议。

![](../Images/image058.jpg)

图 56:组织引用工具栏

但是请记住，这并不能保证所有事情都 100%正确。一些库使用一些非常聪明的技巧来到达它们需要的地方，偶尔 R#也不能正确检测它们的用法。

为了安全起见，在进行这种大规模更改之前，请始终保存您的项目并进行备份。这样，如果出了什么问题，你可以很容易地立即回到你开始的地方。

### 模式搜索(“发现一切”的圣杯)

最终的搜索工具必须是我在任何代码编辑器或 IDE 中见过的最强大的搜索工具之一。我一般不做模因文化，但在这种情况下这是绝对有道理的:

![](../Images/image059.jpg)

图 57:寻找所有事物迷因

模式搜索超越了简单字符串的搜索，而是向您介绍了一个全新的概念，即能够可视化地创建复杂的搜索场景，以不断增长的专业方式检查代码。

您还可以使用“R#选项”对话框永久保存常用搜索模式的集合，如前所述，这些模式可以与团队的其他成员共享。

结构模式也可以更进一步。您可以定义它们，然后设置它们来消除常见的代码气味。稍后您将会看到更多关于这方面的内容，但是现在，要知道 R#在您键入时会一直关注您的代码。在此过程中，它会留意开发人员使用的常见模式，并提出改进建议。

例如，R#可能会关注“For Each”循环用法，其中整个循环可以简单地用单个 LINQ 风格的 select 语句替换。

使用结构模式，您可以轻松地设置自己的解决方案范围的代码气味检测，然后决定如何处理它们。一个实际的例子将有助于证明我的意思。图 58 显示了最近从 Java 源代码转换而来的一个项目的代码片段:

![](../Images/image060.jpg)

图 58:从 Java 转换而来的 C#代码片段

Java 程序员使用的一种常见模式是将`Format`函数与`StringBuilder`类的 Java 实现一起使用，以生成格式化字符串。这很容易转换成 C#，因为我们所要做的就是在`Format`调用前加上`string`，一切都很好。

然而，C#的字符串生成器有一个`AppendFormat`方法，它采用与`string.Format`完全相同的参数，但是给出了更简洁的源代码。

让我们使用 R#的结构模式来检测、通知和帮助改变这种代码气味。

单击**重新搜索** > **查找** > **搜索模式**打开模式定义对话框:

![](../Images/image061.jpg)

图 59: R#结构搜索模式对话框

如果您查看转换后的代码，我们希望搜索一个属于`StringBuilder`类型的表达式，后跟一个句点和关键字`Append`。这个关键词后面是短语`string.Format()`，它包含两个参数——一个格式字符串和可变数量的参数。在“搜索模式”对话框中，输入以下结构化搜索字符串:

![](../Images/image062.jpg)

图 60:查找转换后的 Java 代码气味的结构化搜索模式

开头的`$SB$`部分表示字符串生成器表达式，`$FORMAT$`部分表示格式字符串，`$PARAMETERS$`部分表示`string.Format`调用中的剩余参数。如果这些最初是红色而不是蓝色，您需要定义它们及其类型。

然而，在 R# 8.2 中(与早期版本相比)，我很高兴地发现 R#自动计算出我在做什么，并为我设置参数。然而，即使您有这个能力，您仍然需要调整参数设置。

在“结构化图案”对话框的右侧，您应该会看到类似于以下内容的部分:

![](../Images/image063.jpg)

图 61:结构化搜索参数

如果您还没有添加任何内容，请在下一组动作中使用**添加占位符**而不是**编辑**。

点击(或添加) **SB** ，然后点击**编辑**。您应该会看到以下内容:

![](../Images/image064.jpg)

图 62:SB 参数的表达式编辑器

确保选择了**表达式占位符**，名称设置为 **SB** ，表达式类型设置为**系统。Text.StringBuilder** ，并检查**旁边的框是否正是这种类型**。然后点击**确定**。

这将确保 R#只搜索字符串构建器类型的表达式，后面跟着追加，同时也遵守其他标准。

就像使用 SB 参数一样，单击**格式化**，然后单击**编辑**并调出该令牌的属性:

![](../Images/image065.jpg)

图 63:FORMAT 参数的表达式编辑器

对于 FORMAT，我们希望一个字符串出现一次，并且只能出现一次；我们还希望很快使用匹配的文本，所以我们希望这是一个参数占位符。确保 FORMAT 的设置与图 63 对话框中的设置相匹配，然后点击**确定**。

最后，对 PARAMETERS 标记进行同样的操作；这个将用于抓取`string.Format`呼叫中剩下的任何东西。因为`string.Format`取的参数数量是可变的，我们需要保证我们把它们都抓取了。

按如下方式设置参数选项:

![](../Images/image066.jpg)

图 64:参数的表达式编辑器

您将在这里看到，我们希望确保至少有一个参数，但我们并不关心还有多少，所以我们指定了一个最小值，而没有最大值。

如果您将**在**中查找(靠近底部)设置为**当前文件**并单击**查找**按钮，您应该会得到类似以下内容的结果(假设您使用的是类似的代码):

![](../Images/image067.jpg)

图 65:字符串构建器结构化模式搜索的结果

我只将其设置为当前文件，因为我知道这是唯一一个具有此模式的文件，但是我可以轻松地将搜索设置为解决方案范围内的，然后在我的解决方案中遍历并找到此模式的每一次出现。

现在，只需关闭结果，然后从 R#菜单中，重新打开**模式搜索**对话框。

如果您向对话框的右上角看，您会看到两个按钮:“查找”和“替换”。如果点击**替换**，你的对话框应该会变成如下所示:

![](../Images/image068.jpg)

图 66:启用替换选项的结构化搜索对话框

您现在可以做的是在下面的框中输入一个替换字符串，它可以使用您在搜索中指定的所有参数。将替换图案输入下半部分，如下所示:

![](../Images/image069.jpg)

图 67:代码气味示例的替换模式

如果一切正常，您应该会看到对话框底部附近的“查找”按钮已更改为“替换”。继续点击它。你会得到一个正常的选择框来决定你想要替换哪些，再点击几下，你会发现你很快消除了那些讨厌的代码味道，让 C#再次成为一个快乐的地方。

印象深刻？我们还有一个锦囊妙计——按下 **Ctrl+Z** 来撤销最后一次更改，并让我们的代码重新散发气味。

一旦我们恢复了原来的`string.Format`行，前往 **ReSharper** > **选项** > **代码检查** > **自定义模式**。你应该有这样的结局:

![](../Images/image070.jpg)

图 68:结构化模式的 R#选项对话框

如果你点击**添加图案**，你会看到你原来的图案仍然在它的编辑框中显示出来，就像下图一样:

![](../Images/image071.jpg)

图 69:从选项调用的 R#模式编辑框

但是这次，您应该看到现在有两个描述框，每个编辑输入下一个。代码编辑器中的 R#使用这些描述来突出显示并指出与“追加”代码自动匹配的代码气味。

第一个由工具提示使用；当您将鼠标悬停在编辑器中突出显示的图案上时，第二个图案会显示为 Alt+Enter 快速修复菜单中的名称。现在添加**用法可以在第一个描述中改为 AppendFormat** ，在第二个描述中**改为使用 AppendFormat** 。您还会看到您有一个模式严重性下拉菜单。您可以将其更改为我们在本书前面讨论的任何警告和错误条件。如果您将其设置为错误，那么如果您的项目或解决方案包含任何与此模式匹配的内容，您实际上可以阻止它的生成。现在让我们将严重性更改为**显示为警告**，然后单击**添加**。

如果你现在点击**保存**保存到默认设置位置，然后看看你的编辑器，你会看到你的右边有黄色的警告标记和彩色下划线，每一行下面都有工具提示。

![](../Images/image072.jpg)

图 70:显示 R #对附加结构化模式的反应的 Visual Studio 编辑器

按下**Alt+回车**或点击快速修复菜单，你会看到替换描述现在作为一个选项出现:

![](../Images/image073.jpg)

图 71:显示附加代码气味修复选项的 R#快速修复菜单

正如预期的那样，选择菜单选项或双击 Alt+Enter 将快速解决问题，就像您对任何其他 R# Alt+Enter 操作所做的那样。

我相信你能想到很多创造性的用途。例如，我在自己的数据库中设置了结构化模式，以便在数据访问技术之间快速切换；这是通过寻找“SQLite*”样式模式并用“PSql*”替换它们来完成的，当激活时，它允许我轻松快速地替换连接器、字符串构建器、表适配器和各种其他东西。也请记住，这些模式被保存到“团队共享”设置中，如前所述，这意味着当您设置并共享它们时，您的整个团队都可以访问它们。

“查找”菜单上的最后三个选项都与标记和导航到代码中找到的区域有关。**突出显示文件**中的用法，在适当的情况下，将关闭您可能打开的任何搜索对话框，并突出显示与您刚才执行的任何搜索相匹配的任何内容。

如果您要求的话，这些亮点可以并且将跨越多个文件。解决方案范围内，项目范围内，甚至只是文件的本地，每一个匹配的标准将被突出显示。

为了帮助进行文件跨越，您会发现“查找”菜单中显示的最后两个选项是**转到上一个位置**和**转到下一个位置**，这两个选项完全按照它们在 tin 上说的做，并且允许您通过简单的按键在搜索结果中来回跳转。

### 编辑工具

在本章的最后一节，我们将把注意力转向 R#为开发人员提供的编辑工具。

与前面的部分一样，我们将从主菜单的展开图开始:

![](../Images/image074.jpg)

图 72: R#编辑菜单

您在这里看到的许多选项专门用于完成您当前正在键入的语句，或者您当前正在处理的代码片段和变量名。

**Complete Symbol** 例如，在功能上与大多数 VS 用户每天看到的普通 Visual Studio IntelliSense 完全相同。

**进口符号**另一方面，就像类固醇上的 IntelliSense。此选项不仅会在本地命名空间、类或其他本地对象中查找匹配项，还会查看当前项目或解决方案的整体情况。然后，它将呈现一个非常像普通的智能感知完成列表的列表，并添加了列出名称空间、程序集和任何其他可以从您当前的源代码位置访问的东西的选项。

例如，如果我在我的项目中安装了作为 NuGet 包的自动映射器，但是还没有添加`using`或其他对库的引用。我可以开始输入自动映射器的一个符号，导入符号将正确识别它；可以通过在 AutoMapper 中加入一个`using`条款来实现上述引用。

R#不仅会为我完成语句，还会确保任何`using`语句或使事情正常运行所需的进一步引用也被添加到我当前的源文件中。

![](../Images/image075.jpg)

图 73:注册前显示自动映射器的导入符号完成弹出菜单

下一个菜单选项是**智能代码完成**，与前两个一样，它旨在完成您当前正在处理的语句或部分语句。然而，智能代码完成不同于其他代码完成的地方在于它对变量和类型的处理。

智能代码完成仅显示候选项，这些候选项要么是相同类型的，要么是兼容类型的，或者可以限制在与您键入的条目相同的接口、对象或抽象类型中。这意味着智能完成主要面向函数参数的完成，或者已经声明和已知的结果类型。

它减少了您将代码错误添加到项目中的机会，因为它不让您选择它知道不会起作用的东西。虽然它仍然不是万无一失的(例如，您可以将一个整数赋给一个 double)，但它确实防止了您经常在初级和见习开发人员生成的代码中看到的许多错误类型。

如果您使用的是特定的接口，那么只列出符合该接口的类类型会有所帮助，而不是列出拼写相似或在同一类型族中的对象，这通常会缩短您拥有的选项列表，并使菜单更容易导航。

**完整声明**是上述所有菜单选项的合并，只是用来将所有内容打包在一个菜单下。这里的优点是，您可以在同一个动作中执行所有三种类型的完成。就我而言，我没有在其他三个选项上设置快捷键，只有在最后一个选项上。当我的自定义快捷键被按下时，我可以在适当的时间从菜单中选择最佳选项。

顶级组中的最后两个选项主要是从文档的角度帮助您作为开发人员。当你的光标放在你的源代码中一个获取参数的区域时，激活**参数信息**选项将显示如下参数信息提示:

![](../Images/image076.jpg)

图 74: R#参数信息提示

参数提示将向您显示解决方案中任何代码的参数，或者您可能加载的任何框架和第三方库的参数。它通过定期检查应用程序的环境，并缓存它在加载的程序集的元数据中找到的可用内容来实现这一点。

**显示快速文档**也是一个类似的开发辅助工具，因为它试图给你一个当前定位的函数或方法调用的微型帮助视图:

![](../Images/image077.jpg)

图 75: R#快速帮助弹出菜单

就像参数提示一样，这也将尝试自动化解决方案中您自己的代码和项目的文档。如果您使用 Visual Studio 内置的 XML 注释系统，并正确标记您的方法，快速帮助将构建像上面这样的动态文档提示，并在解决方案工具包中显示开发人员编写软件所需的信息。如果反对的话。NET 框架或其他第三方程序集，那么它将尽最大努力获取符号信息或元数据。

就……而言。NET 基础库，R#的内部产品内置了很多这样的工具提示，随时可以使用。默认快捷键是 Ctrl+Shift+F1。