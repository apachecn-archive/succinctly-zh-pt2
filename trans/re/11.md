# 第 11 章回顾

查找允许正则表达式查找跟在另一个模式后面或前面的模式。查找实际上不是匹配或分组，而只是断言模式的其余部分可以被测试匹配。您可以使用环视来检查在您正在搜索的模式之前或之后是否找到模式。

## 向前看

Look-aheads 用于测试您的模式是否被另一个模式所遵循(或没有遵循)。例如，让我们考虑我们有一个城市和州代码的列表。我们想找到任何位于新泽西州、宾夕法尼亚州或特拉华州的城市，而忽略所有其他州。我们的样本数据如下所示:

```
      Baltimore MD
      Trenton, NJ
      Philadelphia PA
      Rochester, NY
      Claymont, DE

```

### 积极的前瞻

我们的英语和正则表达式规则如下所示。我们使用的是`(?=<pattern>)`的积极前瞻模式。

表 14:积极展望未来

| 英国规则 | 正则模式 |
| 创建一个命名组 | `(?<city>` |
| 有消息吗 | `\w+` |
| 关闭组 | `)` |
| 一个或多个逗号或空格 | `[, ]+` |
| 必须后跟 NJ、PA 或 DE | `(?=NJ&#124;PA&#124;DE` |
| 关闭“向前看” | `)` |

如果我们使用正则表达式模式`(?<city>\w+)[, ]+(?= NJ|PA|DE)`，那么下面的结果将返回匹配的。请注意，虽然逗号或空格作为搜索的一部分进行了匹配，但它不是组的集合字符串的一部分。

```
      Baltimore MD
      Trenton, NJ
      Philadelphia PA
      Rochester, NY
      Claymont, DE

```

regex 对象将创建一个包含我们找到的城市名称的组。我们还可以添加第二个命名组来获取状态代码，使用以下模式:

`(?<city>\w*)[, ]+(?=(?<state>NJ|PA|DE))`

这种模式被称为积极的前瞻。在潜在匹配后寻找模式，并确保找到模式。

### 使用密码规则的查找

理解前瞻的一种方法是将其视为条件表达式。我们是说，如果并且只有当你在字符串中找到一个额外的模式时，你才能接受这个模式。让我们看看如何使用它来确保密码符合业务规则。

我们的密码规则非常简单；它必须介于 6 到 15 个字符之间，包含一个大写字母和一个数字。当然，我们对简单的定义和用户的定义可能会有所不同。既然我们希望测试整个字符串，我们也将使用锚。

我们从创建密码组的规则开始，前提是我们找到一个 6 到 15 个字符长的字母串。

`^(?<pwd>(?=\w{6,15}$).*)`

本质上，我们的组将匹配所有字符(。*)只要满足长度在 6 到 15 个字符之间的条件。然而，我们需要额外的条件，所以我们在表达式中添加了另一个前瞻模式。这确保了除了 6 到 15 个字符之外，至少还能找到一个数字。

**`^(?<pwd>(?=\w{6,15}$)`(?=.*?\d)`。*)`**

我们的最后一条规则需要一个大写字母，所以我们也添加了这个前瞻模式。

**`^(?<pwd>(?=\w{6,15}$)(?=.*?\d)`(?=.*?[A-Z])`。*)`**

我们的最终表达是“只要满足三个前瞻条件，就接受所有字符。”您可以在您的模式中有多个外观，以使搜索规则尽可能详细。

### 消极向前看

现在，让我们假设我中了彩票，并决定给自己买一辆雷克萨斯。但是，我不想要混血儿，叫我生态不友好。所以我想扫描网上的广告找一辆雷克萨斯汽车，但我不想要混合动力车。用英语来说:找到任何雷克萨斯车型，除非它是混合动力车。为了构建表达式，我们使用**(？！<模式> )** 消极前瞻，如表 15 所示。

表 15:消极的前瞻

| 英国规则 | 正则模式 |
| 雷克萨斯这个词 | `Lexus` |
| 任意数量的空格 | `\s+` |
| 创建一个命名组 | `(?<model>` |
| 两个字母 | `[A-Z]{2}` |
| 关闭群组 | `)` |
| 混合动力汽车紧随其后 | `(?!Hybrid)` |

现在，我们找到一个分类广告，其内容如下:

`I am selling my 2013 Lexus CT Hybrid, stop by for a test drive.`

regex 模式在上面的文本中找不到匹配项，但是对于下面的广告，它会找到匹配项:

`I am selling a 2012 Lexus RX with low mileage and a great price!`

该广告将匹配模式`Lexus\s+(?<model>[A-Z]{2})(?!\sHybrid)`，模型组将包含 RX。

### 回到我们的密码

现在，让我们重温一下我们的密码正则表达式。用户不喜欢大写要求，所以我们决定删除它。我们现在更简单的正则表达式模式是这样的:

**`^(?<pwd>(?=\w{6,15}$)(?=.*?\d).*)`**

但是，我们不想接受太容易获得的密码，所以我们将添加一些条件逻辑来拒绝某些密码。我们这样做是带着消极的展望。我们的新模式是:

**`^(?<pwd>(?=\w{6,15}$)(?=.*?\d)(?!abc123|123456|password\d).*)`**

现在的一种模式是密码必须在 6 到 15 个字符之间，至少有一个数字，并且不能是 abc123 或 123456，也不能是单词 password 后跟一个数字。

## 向后看

“后视”的工作方式与“前视”相似，只是它们检查搜索模式之前的模式。隐藏语法是:

`(?<= <pattern> )`正面落后，模式必须在结果文本之前找到

`(?<! <pattern> )`负后视，结果文本前不得发现图案

### 积极的回头看

举个例子，让我们考虑一个包含个人地址信息的 JSON 文件。

```
      {
          "firstName": Michelle,
          "lastName": Obama,
          "age": 50,
          "address": {
              "streetAddress": 1600 Pennsylvania Ave,
              "city": Washington,
              "state": DC,
              "zipCode": 20500
          },
      }
      {
          "firstName": Mary,
          "lastName": Bachman,
          "age": 24,
          "address": {
              "streetAddress": 105 Fayette Street,
              "city": Conshohocken,
              "state": PA,
              "zipCode": 19428
          },
      }

```

我们的应用程序需要从这个 JSON 文件中提取住在宾夕法尼亚州的每个人，所以我们需要确认当前记录有一个 PA 的州代码或拼写出来的州。然而，我们不想简单地搜索州名，因为在华盛顿州 DC 的宾夕法尼亚大道上有一座相当著名的建筑。

寻找宾夕法尼亚居民的 regex 模式很简单:

**`(?<state>PA|Pennsylvania)`**

该模式意味着找到任何宾夕法尼亚州或宾夕法尼亚州，并将其放入名为**州的组中。**当然，在这个例子中，米歇尔·奥巴马的 JSON 条目也会出现，因为她住在宾夕法尼亚大道。

为了确保我们只从 JSON 文件中的“状态”条目中找到状态代码，我们使用了一个正向查找。其结构如下所示:

表 16:积极的展望-落后

| 英国规则 | 正则模式 |
| 必须先找到“状态” | `(?<=\"state\":)` |
| 现在是一个空间 | `[ ]` |
| 任意数量的字符 | `.*` |
| 创建一个命名组 | `(?<state>` |
| 要么是宾夕法尼亚州，要么是宾夕法尼亚州 | `PA&#124;Pennsylvania` |
| 关闭群组 | `)` |

我们得到的正则表达式模式定义如下:

**`(?<=\"state\":)[ ].*(?<state>PA|Pennsylvania)`**

这将发现玛丽的记录，因为她住在宾夕法尼亚州，并将跳过米歇尔的记录，因为她住在 DC。我们还可以添加一个前瞻，在这种情况下，如果我们想确保还可以找到邮政编码字段:

**(？< =\ "州\":)[ ]。*(?<州【宾夕法尼亚州 T4】[，]。*(?=\"zipCode\")**

| ![](../Images/note.png) | 注意:这种模式需要使用单行选项，以允许句点字符也匹配新的行字符。 |

你可以自由地将先行搜索和落后搜索结合起来，专注于你要找的文本。

我们可以使用类似的模式找到这个人的年龄，匹配一个两位数的数字，只要它前面有关键字“年龄”。

### 消极观望

消极的观望表示寻找一个没有其他模式的模式。正则表达式语法是**(？<！**后跟一个模式和一个右括号。例如，假设我们想在一个 Windows 主机文件中查找所有网站，但想排除注释行中的网站。示例主机文件可能如下所示:

```
      # For any domain names you would rather not see, simply add a line
      # that reads "127.0.0.1 machine.domain.tld". This will redirect any
      # requests to that host to your own computer.
      #<localhost>
      127.0.0.1 localhost
      127.0.0.1 localhost.localdomain
      255.255.255.255 broadcasthost
      127.0.0.1 local
      127.0.0.1 www.badStuff.net
      #</localhost>

```

我们现在需要一个简单的正则表达式模式来查找文件的 IP 地址，除非它们前面有一个#注释标记。正则表达式模式如下所示:

**`(?<ip>\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})(?<!#.*)`**

第一组寻找一个非常简单的 IP 地址(它不限于 255 的整数，因为实际的 IP 地址检查需要这样做)。第二个(非匹配组)是一个否定查找的代码，它表示只有当有一个非注释字符，任何数量的字符，后跟行尾标记(我们使用多行选项使$代表行尾)时，才匹配 IP 地址。

## 总结

查找是有用的模式，可以让您在搜索模式中执行条件逻辑。仅当找到(或未找到)一个或多个其他模式时，才接受匹配。它们为正则表达式模式匹配逻辑提供了非常强大的补充。