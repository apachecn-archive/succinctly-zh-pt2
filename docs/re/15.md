# 十五、优化你的规则

一个处理大量文本的复杂正则表达式模式在内存和处理时间方面都是相当耗费资源的。在这一章，我们可以考虑做几件事来加快你的表达速度。请记住，您对正在搜索的数据了解得越多，就越能优化正则表达式的性能。

此外，请记住，正则表达式处理非常快，除非您试图节省毫秒，否则优化很可能不会被注意到。如果你需要花几个小时来优化一个每月使用一次的正则表达式模式，那么要花很长的时间节省毫秒来补偿你的开发努力。在设计正则表达式时考虑优化，那么您就不需要回来重新访问代码。

## 交替

虽然处理差异很小，但将更可能发生的事件放在交替列表的开头是有意义的。例如，如果你正在编写一个正则表达式来验证网站的域名，你应该列出 **com** ，然后是**网**，然后是 **org** 等等。这是任何顺序搜索处理的一般经验法则；将最有可能的匹配项放在列表的开头。

## 懒惰/贪婪量词

如果搜索字符串相对较小并且接近文本的开头，惰性量词可能会比贪婪量词运行得更快。例如，如果我们使用贪婪量词

### 。*

要在一个大的 HTML 文档中寻找标签，这个过程会将整个 HTML 文档加载到内存中。使用贪婪*模式，试图在我的栈溢出配置文件的源代码中找到一个

### 模式花费了大约 8 毫秒。使用惰性模式，同样的搜索在不到. 5 毫秒的时间内运行。

当然，如果您正在搜索一个您期望是整个字符串或者至少是大部分字符串的模式，则情况正好相反。在这种情况下，您宁愿坚持使用贪婪操作符，通过查看整个字符串来预测更有可能更快发生的匹配。

## 非捕获组

如果您的处理依赖于组，则应该只捕获您计划在表达式中使用的组。

**`(?:`** `<pattern> **)**`

上面的语法基于所示的<pattern>创建了一个未捕获的组。例如，请参见以下模式:</pattern>

**`(?<first>\w+)\s(?:\w+)\s`**

提取一个句子的前两个单词，当你可以丢弃第二个单词时，比命名第二个组快大约一毫秒。

## 编译表达式

如果您将 Microsoft 编译选项设置为 on，那么正则表达式将首先被编译并存储在缓存中。第一次遇到正则表达式时，正则表达式引擎将编译它并将其放入缓存中。对相同正则表达式模式的后续调用将运行得更快。

### 缓存大小

正则表达式的默认缓存大小为 15 个条目。您可以使用**缓存大小**属性设置缓存大小。它是 regex 对象上的一个静态属性，可以设置为 0 来清除缓存，也可以设置为任何数字来更改缓存大小。

## 禁用回溯

回溯是 regex 引擎在第一个分支失败时尝试替代路径的过程。如果你知道回溯不会成功，你可以指示正则表达式引擎不要费心去尝试。例如，我们需要一个简单的正则表达式模式来检查文件是否包含有效的 HTML 语法，或者文本是否以**<>**开头，以 **< /html >** 结尾。

**`(<html>.*</html>)`**

如果使用上面的模式，那么 regex 引擎会查看文件，看到第一个标签是，最后一个标签是。如果没有，正则表达式引擎将尝试文本中的其他路径，看看是否匹配。然而，我们知道，如果没有找到这样的匹配，那么文件对于我们的目的是无效的。

通过添加？>非回溯字符到我们的表达式，它变成如下:

**`(?><html>.*</html>)`**

如果第一次尝试失败，我们指示发动机放弃。在一个好的文本大小上，我看到通过消除回溯节省了 3 到 7 毫秒。然而，就我们的目的而言，它很可能会失败。

| ![](img/note.png) | 注意:如果您使用。*语法，请记住包含 SingleLine 选项，因为。通常与换行符不匹配，换行符很可能在文本文件中找到。 |

## 使用锚

另一个优化是在可能的情况下使用锚，特别是在线锚或弦锚的起点和终点。这允许正则表达式引擎简化它的搜索来检查整个字符串。如果整个字符串与模式不匹配，并且锚点字符指示模式必须在开头或结尾找到，那么如果在锚点位置没有找到预期的模式，正则表达式引擎可能会很快“失败”。

## 总结

正则表达式处理的优化是一个你应该在一开始就养成的习惯，而不是在测试完正则表达式之后再去优化它。对数据了解得越多，就越有可能应用优化来让正则表达式更快地找到(或不找到)结果。